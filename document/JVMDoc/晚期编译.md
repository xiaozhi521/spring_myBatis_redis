#### 解释器与编译器
      解释器和编译器各有优势：当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译时间，立即执行。当
      程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码变异成本地代码之后，可以获取更高的执行效率。
      当程序运行环境中内存资源限制较大，可以使用解释执行节约内存，反之可以用编译执行来提高效率。同时，解释器还可以
      作为编译器激进优化时的一个“逃生门”，让编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进
      优化的假设不成立，如加载了新类后类型继承结构出现变化、出现“罕见陷阱”时可以通过逆优化退回到解释状态继续执行
      （部门没有解释器的虚拟机中也会采用不进行激进优化的C1编译器担任“逃生门”的角色），因此在整个虚拟机架构中，
      解释器和编译器经常是相辅相成的配合工作的。
      
 - HotSpot 虚拟机中内置了两个即时编译器，称为Client Compiler和Server Compiler，简称C1编译器和C2编译器
 - 解释器和编译器搭配使用的方式在虚拟机中被称为“混合模式”（Mixed Mode）
 
        java version "1.8.0_121"
        Java(TM) SE Runtime Environment (build 1.8.0_121-b13)
        Java HotSpot(TM) 64-Bit Server VM (build 25.121-b13, mixed mode)
 - -client或-server 参数去强制指定虚拟机运行在Client模式还是Server模式
 - -Xint 设置虚拟机强制运行于“解释模式”，这时编译器完全不介入工作，全部代码都使用解释方式执行
 - -Xcomp 设置虚拟机强制运行于“编译模式”，这时优先采用编译方式执行程序，但是解释器仍然要在编译无法进行
    的情况下介入执行执行过程

#### 编译对象与触发条件
 - 运行过程中会被JIT编译器编译的“热点代码”有两类：被多次调用的方法、被多次执行的循环体
    - 被多次调用的方法
        - 由于方法调用触发的的编译，那编译器理所当然的会以整个方法作为编译对象，这种编译也是虚拟机中标准的编译方式
    - 被多次执行的循环体
        - 编译动作是由循环体所触发的，但编译器依然会以整个方法作为编译对象，这种编译方式因为编译发生在方法执行过程中，
            称为“栈上替换”（On Stack Replacement，OSR）
- 热点探测（Hot Spot Detection）
    - 基于采样的热点探测（Sample Based Hot Spot Detection）
        - 虚拟机周期性的检查各个线程的栈顶，如果发现某个方法经常出现在栈顶，这么方法就是“热点方法”
        - 优点：实现简单高效，很容易的获取方法调用关系
        - 缺点：很难精确的确认一个方法的热度，容易因为受到线程阻塞或者别的外界因素的印象扰乱热点探测
    - 基于计数器的热点探测（Counter Based Hot Spot Detection）
        - 虚拟机会为每个方法建立计数器，统计方法的执行次数，如果执行次数超过一定阀值就认为是“热点方法”
        - 优点：统计结果相对来说更加准确
        - 缺点：实现麻烦，需要为每个方法建立并维护计数器，不能直接获取到方法的调用关系
    - 计数器用于统计方法被调用的次数，默认阀值在Client模式下1500次，在Server模式下 10000次，这个阀值可以通过
        参数 -XX:CompileThreshold 来设定。
        - 当一个方法被调用时，会先检查该方法是否讯在被JIT编译过的版本
        - 如果存在，则优先使用编译后的本地代码来执行
        - 如果不存在，则将此方法调用的计数器加1，然后判断调用计数器与回边计数器值之和是否超过方法调用计数器的阀值
        - 如果超过阀值，将会向即时编译器提交一个该方法的代码编译请求
        - 在默认情况下，执行引擎并不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求
            被编译编译器编译完成。当编译完成后这个方法的调用入口地址就会被系统自动改写成新的地址，下一次调用该方法时
            就会使用已编译的版本。
        - 在默认情况下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被
            调用的次数。超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数
            器就会减少一半，这个过程称为方法调用计数器的热度衰减，简称半衰期。
        - -XX:UseCounterDecay 关闭热度衰减
        - -XX:CounterHalfLifeTime 设置半衰期周期时间，单位是秒  
    - 回边计数器
        - 用于统计一个方法中循环替代吗执行的次数，在字节码中遇到控制流后跳转的指令称为“回边”（Back Edge）
        - -XX:OnStackReplacePercentage 间接调整回边计数器的阀值 
        - Client Mode 下的计算公式：方法调用计数器阀值 * OSR比率(OnStackReplacePercentage) / 100 。
            OnStackReplacePercentage 默认为933，如果都取默认值，此模式下回边计数器的阀值为13995
        - Server Mode 下的计算公式：方法调用计数器阀值 * （OER比率(OnStackReplacePercentage) - 
            解释器监控比率(InterpreterProfilePercentage)）/ 100。OnStackReplacePercentage 默认为140，
            InterpreterProfilePercentage 默认值为33，如果都取默认值，此模式下回边计数器的阀值为10700
    
- 编译优化技术
    - 优化技术概览
        1. 编译器策略
           - 延迟编译
           - 分层编译
           - 栈上替换
           - 延迟优化
           - 程序依赖图表示
           - 静态单赋值表示
        2. 基于性能监控的优化技术
            
        3. 基于证据的优化技术
            - 精确类型推断
            - 内存值推断
            - 内存值跟踪
            - 常量折叠
            - 重组
            - 操作符退化
            - 空值检查消除
            - 类型检测退化
            - 类型检测消除
            - 代数化简
            - 公共子表达式消除
        4. 数据流敏感重写
        5. 语言相关的优化技术
        6. 内存及代码位置变换
        7. 循环变换
        8. 全局代码调整
        9. 控制流图变换
    - 与语言无关的经典优化技术之一：公共子表达式消除
    - 与语言相关的经典优化技术之一：数组范围检查消除
    - 最终要的优化技术之一：方法内联
    - 最前沿的优化技术之一：逃逸分析
        1. 栈上分配
        2. 同步消除
        3. 变量替换
        4. -XX:DoEscapeAnalysis 开启逃逸分析
        5. -XX:PrintEscapeAnaLysis （需开启逃逸分析）查看分析结果
        6. -XX:EliminateAllocations 开启标量替换
        7. -XX:EliminateLocks 开启同步消除
        8. -XX:PrintEliminateAllocations 查看标量替换情况
                        