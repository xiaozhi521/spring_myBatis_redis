### 垃圾收集器与内存分配策略
  ####对象已死？
  #### 引用计数算法
    - 很多教科书判断对象是否存活的算法是这样的：给对象中添加一个引用计数器，每当有一个地方引用他时，
    计数器就加1,；当引用失效时，计数器值就减一；任何时刻计数器都为0的对象就是不可能再被使用的。
    - java 中没有选用引用计数器算法来管理内存，其中最主要的原因是他很难解决对象之间的相互循环引用的对象；
    互相引用这对方，导致他们的引用计数都不为0。
   ###### 根搜索算法
        - 基本思路就是通过一系列的名为“GC Roots”的对象最为起点，从这些节点开始向下搜索，搜索所走过的
        路径称为引用链，当一个对象GC Roots 没有任何引用链相连时，则证明此对象是不可用的。
       
   ###### 在java 语言里，可作为 GC Roots 的对象包括下面几种：
   - 虚拟机栈（栈桢中的本地变量表）中的引用的对象
   - 方法区中的 **类静态属性** 引用的对象
   - 方法区中的 **常量** 引用的对象
   - 本地方法栈中 JNI（即一般说的Native方法）的引用的对象
  #### 引用
  - 强引用
    - 强引用是指在程序代码之中普遍存在的，类似 “Object obj = new Object()”这类的引用，
                只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
  - 软引用
    - 软引用用来描述一些还有用，但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出
            异常之前，将会把这些对象列进回收范围之中并进行第二次回收。如果这次回收还是没有足够的内存，
            才会抛出内存溢出异常。
  - 弱引用
    - 弱引用也是用来描述非必需对象的，它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前
  - 虚引用
    -  虚引用是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例
#### 垃圾收集算法
- 标记清除算法
    - 算法分为“标记”和“清除”两个阶段，首先标记处所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象
    - 缺点
        - 标记和清除过程效率不高
        - 标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要
            分配较大对象时无法找到足够的连续内存而不得不触发另一次垃圾收集动作。
- 复制算法
    - 为了解决效率问题，复制算法出现了。
    - 它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活的对象
        复制到另一块上面，然后再把已使用过的内存空间一次清理掉。
    - 这种算法回收新生代，新生代 98% 的对象是朝生夕死的
    - 内存分为一块较大的Eden和两块较小的Survior空间，每次使用Eden和其中一块Survior。当回收时，将Eden和Survior
        中还存活的对象一次性的拷贝到另一块 Survior 空间上，最后清理掉Eden刚才用过的Survior空间。
    - HotSpot 虚拟机默认Eden和Survior的大小比例是8:1
- 标记-整理算法
    - 复制算法在对象存活效率较高时就要执行较多的复制操作，效率将会变低。
    - 标记-整理算法是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
    - 适合老年代
- 分代收集算法    
    - 分代收集算法根据对象存活的周期的不同将内存划分为几块。
    - 一般java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。  
#### **垃圾收集器**  
    收集算法是内存回收的方法论，垃圾收集器就是内存回收的具体体现。
   - Serial 收集器
        - 单线程收集器
        - 虚拟机运行在Client模式下的默认新生代收集器
        - 优点 ：
            - 简单高效，对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然
                可以获得醉倒的单线程收集效率
   - ParNew 收集器
        - Serial 收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数
        （例如：-XX:SurviorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、
        Stop the World、对象分配规则、回收策略等都与 Serial 收集器完全一样
        - 运行在Server模式下的虚拟机中首选的**新生代收集器**
        - 除了 Serial 收集器之外，目前只能与CMS收集器配合工作
        - -XX:UseConcMarkSweepGC 设置ParNew为默认新生代收集器
        - -XX:UseParNewGC 强制指定ParNew为新生代收集器
        - -XX:ParallelGCThreads 设置垃圾收集的线程数
   - Parallel Scavenge 收集器
        - 新生代收集器，使用复制算法的收集器，又是并行的多线程收集器
        - 目标是达到一个可控制的吞吐量
            - 吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/
            （运行用户代码时间 + 垃圾收集时间）
        - 停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户的体验；而高吞吐量可以最高效率的利用
            CPU时间，尽快的完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务
        - -XX:MaxGCPauseMillis  设置控制最大垃圾收集停顿的时间（大于0）
        - -XX:GCTimeRatio 直接设置吞吐量
        - -XX:+UseAdaptiveSizePolicy 开关参数。打开后，不需要手动指定新生代的大小（-Xmn）、Eden与Survior区的
            比例（XX:GCTimeRatio），晋升老年代对象年龄（-XX:PretenureSizeThreshold）等细节参数，虚拟机会根据
            当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量，这种调节方式
            称为GC自适应的调节策略。
   - Serial Old 收集器
        - Serial 收集器的老年代版本，单线程收集器，使用标记-整理算法
        - Client 模式下的虚拟机使用
        - Server 模式下
            - JDK1.5之前与Parallel Scavenge 搭配使用
            - 作为CMS收集器的后备预案，在并发手机发生Concurrent Mode Failure 的时候使用
   - Parallel Old 收集器
        - Parallel Scavenge 收集器的老年代版本，使用多线程和 “标记-整理”算法
   - CMS 收集器
        - 是一种获取最短回收停顿时间为目标的收集器
        - 基于 “标记-清除”算法实现，整个过程4个步骤：
            - 初始标记（CMS initial mark）
            - 并发标记（CMS concurrent mark）
            - 重新标记（CMS remark）
            - 并发清除（CMS concurrent sweep）
        - 初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到
            对象，速度很快，并发标记阶段就是进行GC Roots Tracing 的过程，而重新标记阶段则是为了修正并发标记期间，因用户
            程序继续运作而导致标记产生变动的那一部分对象的标记记录
        - CMS 优点：并发收集，低停顿
        - CMS 缺点：
            - 对CPU资源非常敏感
            - 无法处理浮动垃圾
            - 收集结束会产生大量空间碎片
                -   为了解决这个问题。提供 -XX:+UseCMSCompactAtFullCollection 开关参数，用于在Full GC 服务之后
                额外免费附送一个碎片整理过程。
                - 停顿时间没了，但停顿时间不得不变长了， -XX:CMSFullGCsBeforeCompaction , 这个参数设置在执行
                多少次不压缩的Full GC 后，跟着来一次带压缩的
   - G1 收集器
        - 基于“标记-整理”算法实现的收集器
        - 可以精确的控制停顿，既能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过
            N毫秒
        - G1 将整个java 堆划分为多个大小固定的独立区域（Region），并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个
        优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域
### 内存分配与回收策略
  - 对象优先在Eden分配
  
        大多数情况下，对象在新生代Eden区中分配，当Dden区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。
  - 大对象直接进入老年代
  
        所谓的大对象是指，需要连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组。
        虚拟机提供一个 -XX:PretenureSizeThreshold 参数，令大于设个设置值的对象直接在老年代中分配。
        这样做的目的是避免在Eden区及两个Survior区之间发生大容量的内存拷贝。
        PretenureSizeThreshold 参数是对Serial和ParNew两种收集器有效。
  - 长期存活的对象进入老年代
    
        -XX:MaxTenuringThreshold 设置对象晋升老年代的年龄阀值
  - 动态对象年龄判定
  
        如果在Survior空间中相同年龄所有对象大小的总和大于Survior空间的一半，年龄大于或等于该年龄的对象就可以
        直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄
  - 空间分配担保
     
            